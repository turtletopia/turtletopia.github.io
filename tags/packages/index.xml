<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>packages on Turtletopia: a blog about programming in R</title>
    <link>https://turtletopia.github.io</link>
    <description>Recent content in packages on Turtletopia: a blog about programming in R</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 28 Jul 2022 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://turtletopia.github.io/tags/packages/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Ice Cream for R Programmers</title><enclosure url="icecream.png" type="image/jpg"></enclosure>
      
      <link>https://turtletopia.github.io/2022/07/28/ice-cream-for-r-programmers/</link>
      <pubDate>Thu, 28 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://turtletopia.github.io/2022/07/28/ice-cream-for-r-programmers/</guid>
      <description>


&lt;div id=&#34;what-and-why-ice-cream-is.&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;What and why ice cream is.&lt;/h1&gt;
&lt;p&gt;This post - perhaps contrary to the headline - will not be about eating ice cream. It will, however, be about something we all do too. About something, we do too often, even though we shouldn’t. About debugging with a &lt;code&gt;print()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let’s face it; it happens to us. We have a rich arsenal to fight bugs. We have error messages, advanced tracebacks from rlang, classic &lt;code&gt;browser()&lt;/code&gt; and &lt;code&gt;debug()&lt;/code&gt; functions, logging utilities or IDE built-in breakpoints. And yet. In our code, there happen to be code snippets scattered here and there like the following:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;some_advanced_function &amp;lt;- function(x) {
  print(&amp;quot;HERE&amp;quot;)
  y &amp;lt;- other_function(x)
  print(y)
  more_calculations()
  print(&amp;quot;I HOPE IT GETS THERE!!!!&amp;quot;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’re all lazy, and that’s why we use &lt;strong&gt;print-driven debugging&lt;/strong&gt; (and I’m sure I’ll expand on the laziness at another time). (It’s funny that acutely lazy evaluation is an acutely brilliant solution.) All the other solutions mentioned above require a little more effort, whereas adding a &lt;code&gt;print()&lt;/code&gt; call to the code is almost effortless. &lt;strong&gt;Almost&lt;/strong&gt;. As it usually turns out, the devil is in the detail.&lt;/p&gt;
&lt;p&gt;Since we all do it and we all consider it to be a kind of inappropriate practice, perhaps it would be worth taking some steps to make it more appropriate after all? And at the same time, pay even more tribute to our laziness? That was the idea behind the developer of the &lt;a href=&#34;https://github.com/gruns/icecream&#34;&gt;Python library IceCream&lt;/a&gt;. And this is the idea that guided me and &lt;a href=&#34;https://github.com/lewinfox&#34;&gt;Lewin Appleton-Fox&lt;/a&gt; in creating &lt;a href=&#34;https://github.com/lewinfox/icecream&#34;&gt;R version of icecream&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;how-to-eat-ice-cream-and-why-you-should-do-it.&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;How to eat ice cream and why you should do it.&lt;/h1&gt;
&lt;p&gt;The most basic usage is straightforward. The library’s primary function is &lt;code&gt;ic()&lt;/code&gt;, which takes an argument of any kind, prints its value to the screen and returns it invisibly.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(icecream)

ic(12)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ℹ ic| `12`: num 12&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can immediately see the first advantage over print: &lt;strong&gt;typing &lt;code&gt;ic()&lt;/code&gt; is faster than typing “print”&lt;/strong&gt;. Since we are here because we like to make our life more convenient, that might be important to one.&lt;/p&gt;
&lt;p&gt;That would be useless, though, if we could not include it within a function. And of course, we can do it. We will reuse the previous example but replace the &lt;code&gt;print()&lt;/code&gt; calls with &lt;code&gt;ic()&lt;/code&gt;. And let’s pack the function and other functions into an external file called &lt;code&gt;external.R&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# external.R

other_function &amp;lt;- function(x) x * 5 - 7
more_calculations &amp;lt;- function() NULL

some_advanced_function &amp;lt;- function(x) {
  ic(&amp;quot;HERE&amp;quot;)
  y &amp;lt;- other_function(x)
  ic(y)
  more_calculations()
  ic(&amp;quot;I HOPE IT GETS THERE!!!!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;source(&amp;quot;external.R&amp;quot;)
some_advanced_function(42)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ℹ ic| `&amp;quot;HERE&amp;quot;`: chr &amp;quot;HERE&amp;quot;
## ℹ ic| `y`: num 203
## ℹ ic| `&amp;quot;I HOPE IT GETS THERE!!!!&amp;quot;`: chr &amp;quot;I HOPE IT GETS THERE!!!!&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That works well. And you can also see another reason to use &lt;code&gt;ic()&lt;/code&gt;: &lt;strong&gt;it automatically prints expression alongside its value&lt;/strong&gt;. That might be very useful, especially if we have many prints and don’t want to check which one corresponds to which value.&lt;/p&gt;
&lt;p&gt;But, as you have probably noticed, this verbose printing introduces redundancy when printing &lt;em&gt;HERE&lt;/em&gt; etc. Well, that is on purpose. With icecream &lt;em&gt;you don’t need to provide a message to get the context&lt;/em&gt;. Let’s modify the function slightly and remove those locator messages.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# external_2.R

some_advanced_function_2 &amp;lt;- function(x) {
  ic()
  y &amp;lt;- other_function(x)
  ic(y)
  more_calculations()
  ic()
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;source(&amp;quot;external_2.R&amp;quot;)
some_advanced_function_2(42)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ℹ ic| `some_advanced_function_2()` in external_2.R:3:2
ℹ ic| `y`: num 203
ℹ ic| `some_advanced_function_2()` in external_2.R:7:2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you can see that &lt;code&gt;ic()&lt;/code&gt; is even more clever! &lt;strong&gt;It includes as precise information about the file and position in the file as possible if you call it without arguments.&lt;/strong&gt; This context inclusion makes debugging even more seamless!&lt;/p&gt;
&lt;p&gt;When the context of the file is not available (e.g. when calling a function created from a console), an environment of the source is printed:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a_function &amp;lt;- function(x) {
  x + 2
  ic()
}

a_function(0)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ℹ ic| `a_function()` in &amp;lt;env: global&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(&lt;em&gt;Side note:&lt;/em&gt; I need to admit that I lied a little with the above code: compiling this code with R markdown does not preserve the file names when sourcing. The output is pasted manually because that would call it from the console. knitr removes references when calling &lt;code&gt;source&lt;/code&gt;, and we have not found a way around it. But that is not a concern since Rmd documents are usually final results.)&lt;/p&gt;
&lt;p&gt;What is the biggest problem with &lt;em&gt;print-driven debugging&lt;/em&gt;? Our memory. It might be a problem if we forget to remove those &lt;code&gt;print()&lt;/code&gt;s. Especially when, being irritated, we include some curse words here. And then send it to the client (anticipating questions: I have not done that, but my colleague has…). Thankfully, &lt;code&gt;ic()&lt;/code&gt; is help here! It is enough to call:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ic_disable()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;to disable all the &lt;code&gt;ic()&lt;/code&gt; calls. They behave just like a regular &lt;code&gt;identity()&lt;/code&gt; now. There is a counterpart, &lt;code&gt;ic_enable()&lt;/code&gt;, which does the opposite. If you are, for example, building a shiny app, you can enable and disable &lt;code&gt;ic()&lt;/code&gt; conditionally depending on whether your app is in development or production mode. Additionally, using &lt;code&gt;ic()&lt;/code&gt; when building a package is a safety net. If you don’t import the &lt;code&gt;ic()&lt;/code&gt; function and rely solely on loading the library externally, the package will not pass checks.&lt;/p&gt;
&lt;p&gt;Last and not least, there is a &lt;strong&gt;dose of customization possibilities.&lt;/strong&gt; You can e.g. change the function used to peek and the number of lines printed, as you can see in the chunk below:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# standard settings:
ic(mtcars)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ℹ ic| `mtcars`: data.frame [32 x 11]: $&amp;#39;mpg&amp;#39;: dbl [32], $&amp;#39;cyl&amp;#39;: dbl [32], ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# modified settings:
options(icecream.max.lines = 5)
options(icecream.peeking.function = head)

ic(mtcars)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ℹ ic| `mtcars`: 
## mpg cyl disp  hp drat    wt  qsec vs am gear carb
## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4
## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4
## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1
## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;a-few-words-on-ice-cream-production.&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;A few words on ice cream production.&lt;/h1&gt;
&lt;p&gt;The inner workings of icecream are pretty curious, and I encourage you heavily to explore &lt;a href=&#34;https://github.com/lewinfox/icecream/blob/master/R/ic.R&#34;&gt;the code&lt;/a&gt; if you want to see &lt;a href=&#34;https://rlang.r-lib.org/&#34;&gt;rlang&lt;/a&gt; in action. I will comment on a few code snippets to give you a glimpse.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;ic()&lt;/code&gt; is possible because we can suspend the evaluation of arguments:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ic &amp;lt;- function(x) {
  # capture the input to allow us to work with the expression and value separately
  q &amp;lt;- rlang::enquo(x)
  ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, &lt;code&gt;q&lt;/code&gt; holds &lt;strong&gt;the expression&lt;/strong&gt; alongside with its &lt;strong&gt;evaluation environment&lt;/strong&gt;. We can quickly transform it into a string by &lt;strong&gt;deparsing it&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;deparsed_expression &amp;lt;- rlang::expr_deparse(rlang::quo_get_expr(q))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To get the value of the expression, we can enforce &lt;strong&gt;evaluation&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;- rlang::eval_tidy(q)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Getting the precise location of the &lt;code&gt;ic()&lt;/code&gt; call is more tricky. We can do it, however, with the usage of rlang functions for analyzing the &lt;strong&gt;stack of calls&lt;/strong&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# this code is simplified and not guaranteed always to work

# inspecting the traceback and extracting the call stack:
trace &amp;lt;- rlang::trace_back()
call_stack &amp;lt;- trace$call

# getting length of the call stack:
num_calls &amp;lt;- length(call_stack)

# accessing the second-to-last call (to omit the `ic` call) and extracting parent reference:
parent_ref &amp;lt;- call_stack[[num_calls - 1]][[1]]

# extracting location from the reference:
ref &amp;lt;- attr(call_stack[[num_calls]], &amp;quot;srcref&amp;quot;)
loc &amp;lt;- rlang:::src_loc(ref)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that &lt;code&gt;rlang:::src_loc()&lt;/code&gt; is not an exported function, as it is not meant for end users of the package. We allowed ourselves to borrow the code of the function as it is crucial for our package.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;plans-for-the-ice-cream-industry-and-conclusion.&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Plans for the ice cream industry and conclusion.&lt;/h1&gt;
&lt;p&gt;If you practice using print to debug your programs, do it with class. That is what icecream offers. Its main advantages are less typing, convenient information printing, the inclusion of context, easy disabling and customization. The package is still under development, and our current goal is to fully implement the original Python version’s functionalities. I encourage you to give it a try!&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;If you have any suggestions for the &lt;a href=&#34;https://github.com/lewinfox/icecream&#34;&gt;icecream&lt;/a&gt;, do not hesitate to leave an issue on our repo.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Overview: Sorting Version Codes</title><enclosure url="https://turtletopia.github.io/images/logo.png" type="image/jpg"></enclosure>
      <link>https://turtletopia.github.io/2022/07/16/overview-sort-version-codes/</link>
      <pubDate>Sat, 16 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://turtletopia.github.io/2022/07/16/overview-sort-version-codes/</guid>
      <description>

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#problem-statement&#34;&gt;Problem statement&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#solutions&#34;&gt;Solutions&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#using-base-r&#34;&gt;Using base R&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#using-gtools&#34;&gt;Using gtools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#using-naturalsort&#34;&gt;Using naturalsort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#using-stringrstringi&#34;&gt;Using stringr/stringi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#using-versionsort&#34;&gt;Using versionsort&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#semantic-version-codes&#34;&gt;Semantic version codes&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#using-semver&#34;&gt;Using semver&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#using-semverutils&#34;&gt;Using semverutils&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;problem-statement&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Problem statement&lt;/h2&gt;
&lt;p&gt;Different versions of software are traditionally described using version codes. These codes contain usually numerical values and subsequent versions increment these codes, allowing them to be sorted. The standard is to use “&lt;a href=&#34;https://semver.org&#34;&gt;semantic versioning&lt;/a&gt;”, where codes are in the form of “major.minor.patch”; the bigger the update, the more important number is incremented.&lt;/p&gt;
&lt;p&gt;However, not all software obey semantic versioning standard.&lt;/p&gt;
&lt;p&gt;Suppose we have a vector of version codes:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;codes &amp;lt;- c(&amp;quot;1.2&amp;quot;, &amp;quot;1.10&amp;quot;, &amp;quot;1.1&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’d expect them to be ordered as 1.1, 1.2, 1.10. If you try to order version codes using base &lt;code&gt;sort()&lt;/code&gt; functionality…&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sort(codes)
## [1] &amp;quot;1.1&amp;quot;  &amp;quot;1.10&amp;quot; &amp;quot;1.2&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;…oh. Where did something go wrong?&lt;/p&gt;
&lt;p&gt;This is what’s called “alphabetical sorting”. It checks characters one by one, including digits. “1” is before “2”, so “10” goes before “2”, no matter the value. Thus, it cannot compare numbers, if they have a different number of digits.&lt;/p&gt;
&lt;p&gt;Numerous software uses the following trick to have it sort correctly: it pads the numbers with leading 0’s until a certain length. For example, your old camera could name photos like &lt;code&gt;00034.jpg&lt;/code&gt;, &lt;code&gt;00164.jpg&lt;/code&gt;, etc. But this is not the approach to use here. We need a different one.&lt;/p&gt;
&lt;p&gt;Sorting version codes requires using something called “natural sort”, where numbers are detected and ordered according to their value (with letters still sorted alphabetically, thus placing e.g. “a99” before “b51”). This is a more intuitive sorting for humans than pure alphabetical sort.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;solutions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Solutions&lt;/h2&gt;
&lt;p&gt;Several packages allow natural sorting of character vectors. There’s even a base R solution! However, not all natural sorting algorithms are adapted to handle version codes, which (usually) have a particular structure with dots and/or dashes. Let’s have a look at the options.&lt;/p&gt;
&lt;div id=&#34;using-base-r&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Using base R&lt;/h3&gt;
&lt;p&gt;There’s a facility in base R allowing the user to handle (numeric) version codes. While there is no simple “sort these strings like they were version codes” function, you can wrap your vector in &lt;code&gt;numeric_version()&lt;/code&gt; and use associated methods, like comparison operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;…), as well as &lt;code&gt;sort()&lt;/code&gt; method for this class. This is what it looks like:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sort(numeric_version(codes))
## [1] &amp;#39;1.1&amp;#39;  &amp;#39;1.2&amp;#39;  &amp;#39;1.10&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are two main problems with this approach, however. But first, let’s quote the documentation:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Numeric versions are sequences of one or more non-negative integers, usually (…) represented as character strings with the elements of the sequence concatenated and separated by single . or - characters.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This means that version codes cannot have any string components or non-standard separators. As described in the semantic versioning standard, letters are allowed in pre-release identifiers and build metadata, so the base solution cannot even handle all valid cases of semantic versioning, much less the variety of version codes that don’t fit these rules.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;using-gtools&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Using gtools&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/r-gregmisc/gtools&#34;&gt;gtools&lt;/a&gt; is a collection of functions to help with simple tasks when writing R packages. It has a &lt;code&gt;mixedsort()&lt;/code&gt; function that detects embedded numbers in strings. However…&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gtools::mixedsort(codes)
## [1] &amp;quot;1.10&amp;quot; &amp;quot;1.1&amp;quot;  &amp;quot;1.2&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;…it is not suited to sorting version codes. The use case here is different, it’s detecting numbers like these in “Aspirin 50mg” and “Aspirin 100mg” (examples taken from the documentation). Dots in version codes are treated as decimal separators, that’s why &lt;code&gt;&#34;1.10&#34;&lt;/code&gt; and &lt;code&gt;&#34;1.1&#34;&lt;/code&gt; are considered equal.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;using-naturalsort&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Using naturalsort&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kos59125/naturalsort&#34;&gt;naturalsort&lt;/a&gt; isn’t written specifically for sorting version codes either, but…&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;naturalsort::naturalsort(codes)
## [1] &amp;quot;1.1&amp;quot;  &amp;quot;1.2&amp;quot;  &amp;quot;1.10&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;…it gets the job done. The difference lies in not treating dots as decimal separators (in fact, naturalsort doesn’t recognize decimals at all). Instead, the code detects numbers and non-numbers, then splits the strings into continuous pieces of numbers and non-numbers. If we were to For example, &lt;code&gt;&#34;1.10-a&#34;&lt;/code&gt; would be split like that:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;split_like_naturalsort(&amp;quot;1.10-a&amp;quot;)
## [1] &amp;quot;1&amp;quot;  &amp;quot;.&amp;quot;  &amp;quot;10&amp;quot; &amp;quot;-a&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These pieces are then used to sort version codes either alphabetically or by value, depending on whether it’s a number or not. Accidentally, this works well for almost all version codes. The only case where it’s working a little weird is when there’s an inconsistency in separators:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;weird_codes &amp;lt;- c(&amp;quot;1.3-6&amp;quot;, &amp;quot;1.3-2&amp;quot;, &amp;quot;1.3.4&amp;quot;)
naturalsort::naturalsort(weird_codes)
## [1] &amp;quot;1.3-2&amp;quot; &amp;quot;1.3-6&amp;quot; &amp;quot;1.3.4&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I like that naturalsort has &lt;code&gt;decreasing&lt;/code&gt; and &lt;code&gt;na.last&lt;/code&gt; parameters, implemented just like in base &lt;code&gt;sort()&lt;/code&gt;. There’s also a &lt;code&gt;naturalfactor()&lt;/code&gt; function that could be useful for long vectors of repeated version codes.&lt;/p&gt;
&lt;p&gt;naturalsort isn’t developed since 2016, but this shouldn’t be considered a problem, since the package is in an already stable state. There’s one pet peeve of mine about this package and it’s the implicit coercion of parameters. Let’s say we accidentally made this call:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;naturalsort::naturalsort(codes,
                         decreasing = c(&amp;quot;true&amp;quot;, &amp;quot;dat&amp;quot;))
## [1] &amp;quot;1.10&amp;quot; &amp;quot;1.2&amp;quot;  &amp;quot;1.1&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Turns out &lt;code&gt;c(&#34;true&#34;, &#34;dat&#34;)&lt;/code&gt; was coerced to logical, then the first element was taken. It should raise an error saying that the arguments are wrong, but – instead – it tries to work at all costs, over-interpreting the parameters. A similar thing would happen with a vector of logical values.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;using-stringrstringi&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Using stringr/stringi&lt;/h3&gt;
&lt;p&gt;You’ve probably already installed &lt;a href=&#34;https://github.com/tidyverse/stringr&#34;&gt;stringr&lt;/a&gt; and/or &lt;a href=&#34;https://github.com/gagolews/stringi&#34;&gt;stringi&lt;/a&gt; if you’ve been using R for a while. Both these packages can do way, way more to strings than just some natural sorting, but we’ll focus on just that. There’s a parameter called &lt;code&gt;numeric&lt;/code&gt; in &lt;code&gt;stri_sort()&lt;/code&gt;, where we can pass &lt;code&gt;TRUE&lt;/code&gt; to sort digits numerically:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# There&amp;#39;s analogous stringr::str_sort() function
stringi::stri_sort(codes, numeric = TRUE)
## [1] &amp;quot;1.1&amp;quot;  &amp;quot;1.2&amp;quot;  &amp;quot;1.10&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The overall implementation seems to base on the same idea of separating numbers and non-numbers, and it has the same behavior on inconsistent separators:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;stringi::stri_sort(weird_codes, numeric = TRUE)
## [1] &amp;quot;1.3-2&amp;quot; &amp;quot;1.3-6&amp;quot; &amp;quot;1.3.4&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are &lt;code&gt;decreasing&lt;/code&gt; and &lt;code&gt;na_last&lt;/code&gt; parameters just like in &lt;code&gt;naturalsort()&lt;/code&gt; and base &lt;code&gt;sort()&lt;/code&gt;; and again, there’s silent argument coercion I despise. At least I can give half a point for raising a warning when only the first element is used.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;using-versionsort&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Using versionsort&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/turtletopia/versionsort&#34;&gt;versionsort&lt;/a&gt; is our solution to this problem. I’ve implemented, documented, tested, and submitted it to CRAN within 24 hours when working on implementing a feature in &lt;a href=&#34;https://github.com/DominikRafacz/deepdep&#34;&gt;deepdep&lt;/a&gt;; obviously, it has changed a bit since then.&lt;/p&gt;
&lt;p&gt;There’s a &lt;code&gt;ver_sort()&lt;/code&gt; function that’s of the main interest here:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;versionsort::ver_sort(codes)
## [1] &amp;quot;1.1&amp;quot;  &amp;quot;1.2&amp;quot;  &amp;quot;1.10&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It works a little differently than other sorts I’ve mentioned before, as it splits the string on separators first (which are sequences of anything that is not a number or a letter), only then separating numbers and non-numbers (i.e. letters). All separators are equal, which gives a little more predictable behavior with inconsistent separators:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;versionsort::ver_sort(weird_codes)
## [1] &amp;quot;1.3-2&amp;quot; &amp;quot;1.3.4&amp;quot; &amp;quot;1.3-6&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;versionsort is still a Work-In-Progress, which means that it lacks &lt;code&gt;decreasing&lt;/code&gt; and &lt;code&gt;na_last&lt;/code&gt; parameters, but this whole analysis serves partially to define requirements for future development (more in soon-to-be-published versionsort Dev Plan).&lt;/p&gt;
&lt;p&gt;There’s one convenient utility versionsort has, though – the pair of functions named &lt;code&gt;ver_latest()&lt;/code&gt; and &lt;code&gt;ver_oldest()&lt;/code&gt;. They return &lt;code&gt;max()&lt;/code&gt; and &lt;code&gt;min()&lt;/code&gt; for version codes, respectively, without the need for sorting the whole vector:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;versionsort::ver_latest(codes)
## [1] &amp;quot;1.10&amp;quot;
versionsort::ver_oldest(codes)
## [1] &amp;quot;1.1&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Stay tuned for the new, improved versionsort!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;semantic-version-codes&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Semantic version codes&lt;/h2&gt;
&lt;p&gt;All these solutions have one thing in common – they don’t detect semantic version codes. There are, however, R packages with this functionality; I’ve found two, described below.&lt;/p&gt;
&lt;div id=&#34;using-semver&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Using semver&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/johndharrison/semver&#34;&gt;semver&lt;/a&gt; is the most used R package for handling semantic version codes. It relies heavily on &lt;a href=&#34;https://github.com/zmarko/semver&#34;&gt;C++ semver&lt;/a&gt; implementation under the hood, but it results in a wide range of functionalities: there are many methods for parsed semantic codes, &lt;code&gt;sort()&lt;/code&gt; included:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;semver_codes &amp;lt;- semver::parse_version(
  c(&amp;quot;1.6.0-dev&amp;quot;, &amp;quot;1.5.10&amp;quot;, &amp;quot;1.5.1&amp;quot;, &amp;quot;1.6.0&amp;quot;)
)
sort(semver_codes)
## [1] Maj: 1 Min: 5 Pat: 1
## 
## [2] Maj: 1 Min: 5 Pat: 10
## 
## [3] Maj: 1 Min: 6 Pat: 0 Pre: dev
## 
## [4] Maj: 1 Min: 6 Pat: 0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Operators as well:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;semver_codes[1:3] &amp;lt; semver_codes[2:4]
## [1] FALSE FALSE  TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can use &lt;code&gt;max()&lt;/code&gt; and &lt;code&gt;min()&lt;/code&gt; too:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;max(semver_codes)
## Maj: 1 Min: 6 Pat: 0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This package has the most functionality of them all…&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;semver::parse_version(&amp;quot;1.0-10&amp;quot;)
## Error in parse_ptr(version): invalid character encountered: -&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;…but is nonetheless limited to semantic version codes.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;using-semverutils&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Using semverutils&lt;/h3&gt;
&lt;p&gt;Sorting numeric codes is not possible in &lt;a href=&#34;https://github.com/ajwtech/semverutils&#34;&gt;semverutils&lt;/a&gt;. You can only check if a version code is higher than others by calling:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;v_code &amp;lt;- semverutils::semVer$new(c(&amp;quot;1.6.0-dev&amp;quot;))
v_code$higherThanAll(c(&amp;quot;1.5.10&amp;quot;, &amp;quot;1.6.0&amp;quot;, &amp;quot;1.5.1&amp;quot;))
## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unfortunately, the answer isn’t even correct, since &lt;code&gt;&#34;1.6.0-dev&#34;&lt;/code&gt; precedes &lt;code&gt;&#34;1.6.0&#34;&lt;/code&gt; due to being a pre-release version.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusion&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;There are a few ways to sort version codes. If your version codes are simple and well-behaved, &lt;code&gt;base::numeric_version()&lt;/code&gt; should be enough. If you need to handle semantic version codes, use &lt;a href=&#34;https://github.com/johndharrison/semver&#34;&gt;semver&lt;/a&gt;. Otherwise, there is no best solution, but &lt;a href=&#34;https://github.com/turtletopia/versionsort&#34;&gt;versionsort&lt;/a&gt; is the closest you can get, especially after the next big update is published.&lt;/p&gt;
&lt;p&gt;Missed a package? Described one incorrectly? Contact us &lt;a href=&#34;https://twitter.com/Rturtletopia&#34;&gt;on Twitter&lt;/a&gt; or make an issue &lt;a href=&#34;https://github.com/turtletopia/turtletopia.github.io/issues&#34;&gt;on Github&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
