---
title: "Shiny Reactivity Tricks, pt. II: Reactives Factories"
author: Dominik Rafacz
date: '2022-08-31'
slug: shiny-reactivity-tricks-pt-ii-reactives-factories
categories: ['Tutorial']
tags: ['r', 'tutorial', 'shiny', 'reactivity', 'environments', 'rlang']
Description: "Moving creation of the reactive objects might be difficult, if you want to do it right. This article shows step-by-step solution to managing environments of evaluation and parametrization of factories producting reactives."
output:
  blogdown::html_page:
    toc: true
images:
  - factory.png
---

# Preface

There was no post last week because the holiday season/master's thesis finishing season/parental pet care season is in full swing and I've been completely crushed. This week isn't easy either, but I didn't want to leave you empty-handed when there's so much to talk about!

This time I wanted to present you with another installment in the shiny tricks series. This time I'm going to present something that isn't quite as 'tricky', but can still be non-obvious to those who don't use reactivity and environments proficiently. I will tell you about factories of reactives. And the tale with start with an example.

# Basic example

**Remark:** As I often use the `shiny::reactive()` function in this article, it will probably not have escaped you that I always wrap the first argument of this function in curly brackets. By doing so, I make it clear that the argument of the function is *an expression*, not its *value*. Most of the time this is not necessary, but it is a habit of mine and helps me keep the code readable.

Suppose we have an application that accepts a number of numeric inputs and performs very complex transformations on them and then plots and outputs the result. Let's start with an example with two inputs.

```r
library(shiny)

ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      numericInput("a", "input a", 1, 0, 100, 1),
      numericInput("b", "input b", 1, 0, 100, 1)
    ),
    mainPanel(
      textOutput("text_a_b"),
      plotOutput("plot_a_b")
    )
  )
)

server <- function(input, output, session) {
  temp_val <- reactive({
    c(
      input[["a"]] + input[["b"]],
      input[["a"]]^3 * input[["b"]],
      27 - (input[["b"]] + input[["a"]])
    )
  })

  output[["text_a_b"]] <- renderText(
    paste(temp_val(), collapse = " -- ")
  )
  output[["plot_a_b"]] <- renderPlot(
    plot(temp_val(), temp_val())
  )
}

shinyApp(ui, server)
```

![Basic example app.](/images/reactives-factory-example.png)

This application takes two inputs and performs an incredibly complex calculation that, in effect, returns a three-element vector. This vector, an intermediate value, is later used for the two outputs. 

Of course, again the calculations themselves, the inputs and outputs are not relevant or even meaningful here.  It's just me with my usual problems of finding simple examples to demonstrate not-so-simple concepts. The only thing that is relevant is that there is a reactive intermediate value calculated from inputs.

So far, nothing complicated. So let's add a little spice.

```r
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      numericInput("a", "input a", 1, 0, 100, 1),
      numericInput("b", "input b", 1, 0, 100, 1),
      numericInput("c", "input c", 1, 0, 100, 1),
      numericInput("d", "input d", 1, 0, 100, 1),
      numericInput("e", "input e", 1, 0, 100, 1)
    ),
    mainPanel(
      textOutput("text_a_b"),
      plotOutput("plot_a_b"),
      plotOutput("plot_b_d"),
      tableOutput("table_c_d"),
      textOutput("table_a_e")
    )
  )
)

server <- function(input, output, session) {
  temp_val_1 <- reactive({
    c(
      input[["a"]] + input[["b"]],
      input[["a"]]^3 * input[["b"]],
      27 - (input[["b"]] + input[["a"]])
    )
  })

  temp_val_2 <- reactive({
    c(
      input[["b"]] + input[["d"]],
      input[["b"]]^2 * input[["d"]],
      8 - (input[["d"]] + input[["b"]])
    )
  })

  temp_val_3 <- reactive({
    c(
      input[["c"]] + input[["d"]],
      input[["c"]] * input[["d"]],
      1 - (input[["d"]] + input[["c"]])
    )
  })

  temp_val_4 <- reactive({
    c(
      input[["a"]] + input[["e"]],
      input[["a"]]^4 * input[["e"]],
      64 - (input[["e"]] + input[["a"]])
    )
  })

  output[["text_a_b"]] <- renderText(
    paste(temp_val_1(), collapse = " -- ")
  )
  output[["plot_a_b"]] <- renderPlot(
    plot(temp_val_1(), temp_val_1())
  )
  output[["plot_b_d"]] <- renderPlot(
    plot(c(1, 1, 1), temp_val_2())
  )
  output[["table_c_d"]] <- renderTable(
    data.frame(x = temp_val_3(), e = exp(temp_val_3()))
  )
  output[["table_a_e"]] <- renderText(temp_val_4())
}
```
I modified the UI and the server to do more things. Everything is centered around the very complex transformation as before, but we have more inputs, more outputs and more temporary values. And above all: more iterations. As you may have already realized, I'm a big opponent of repetition in code: if there's copy-paste somewhere, it can probably be done better. And that's what we're going to try to address. There are two main repeating rhythms in this code: inputs and the calculation of temporary values. The first repetition can be fixed very easily and I've already done analogous things in [the previous part of the article series](/2022/07/09/creating-observers-in-loop-shiny-reactivity-tricks-episode-one/), so I won't go into it this time. Let's deal with the more interesting thing, which is the server-side repetitions

# Solution 1: wrap a function with a reactive.

The thing that jumps to mind almost immediately is the creation of a function that generates these temporary values.

```r

magic_func <- function(name_1, name_2, param) c(
  name_1 + name_2,
  name_1^param * name_2,
  param^3 - (name_2 + name_1)
)

server <- function(input, output, session) {
  temp_val_1 <- reactive({ magic_func(input[["a"]], input[["b"]], 3) })
  temp_val_2 <- reactive({ magic_func(input[["b"]], input[["d"]], 2) })
  temp_val_3 <- reactive({ magic_func(input[["c"]], input[["d"]], 1) })
  temp_val_4 <- reactive({ magic_func(input[["a"]], input[["e"]], 4) })

  # here put the other part of the server code...
}
```
This already looks much, much better! It's more readable and less error-proof, so the advantages alone. And that's basically where we could leave it. But if it satisfied us, we wouldn't read any further.

# Solution 2a and 2b: extract input.

Another thing that can be improved in this solution is to refer to the `input` object every time there are multiple arguments to the `magic_func()` function. So maybe we can move this reference inside the function?

```r

magic_func <- function(name_1, name_2, param) c(
  input[[name_1]] + input[[name_2]],
  input[[name_1]]^param * input[[name_2]],
  param^3 - (input[[name_2]] + input[[name_1]])
)

server <- function(input, output, session) {
  temp_val_1 <- reactive({ magic_func("a", "b", 3) })
  temp_val_2 <- reactive({ magic_func("b", "d", 2) })
  temp_val_3 <- reactive({ magic_func("c", "d", 1) })
  temp_val_4 <- reactive({ magic_func("a", "e", 4) })
  
  # here put the other part of the server code...
}
```

![Output error message.](/images/reactives-factory-error.png)

Unfortunately, we will find that this is not enough. The `input` object is for the interior of the function unknown. This may seem unnatural if you understand the basics of how scopes work in R -- if the object is not found in the current environment, the parent environment is checked (I talked about this in [the previous part of the series](/2022/07/09/creating-observers-in-loop-shiny-reactivity-tricks-episode-one/), I refer you to it again). Here, however, this situation is not so obvious by the fact that the server environment is not in the search path of the environment in which the function is defined. 

This can be resolved in two ways: either move the function definition inside the server, or pass an `input` object as an additional parameter to the function. I leave the proof to the reader.

# Solution 3: wrap a reactive with a function (factory).

We could, however, go even further and reduce code redundancy even more. And this is where we want to create a reactive factory.

What is a factory of reactives? It is simply a function that creates a reactive. Every shiny user should be very familiar with the basic function that is used to create and register reactives -- namely, `shiny::reactive()`.

But this is the most general factory that exists -- you pass it any expression and it turns it into a reactive expression. We would like to have something more concrete, i.e. instead of writing `reactive({ fun(parameters) })` writing `reactive_fun(parameters)`. 

In our case we want to replace

```r
reactive({ magic_func("a", "b", 3) })
```

with

```r
r_magic_func("a", "b", 3)
```

Notice the `r_` I added to the function name. Suggesting that this function actually returns a reactive is a good idea.

So, let's try to make such a function!

```r
r_magic_func <- function(name_1, name_2, param) reactive({
  c(
    input[[name_1]] + input[[name_2]],
    input[[name_1]]^param * input[[name_2]],
    param^3 - (input[[name_2]] + input[[name_1]])
  )
})
```

Does it work? Yes... at least: almost. It will not work unless we take into consideration our experiences from previous solution: it needs to be either defined in the server function or take input as a separate parameter.

But what if we do not to do neither of those? We are really lazy and does not want to type all the parameters that are going to look the same either way. Those "inputs" typed every time are annoying, but if, in addition, we have some other reactive values that we would have to pass on each time, this would be very annoying. On the other hand, defining functions within a server works for small apps, but is rather a bad practice if you have a large, packaged application that wants to keep its code tidy and tests its functions with unit tests. So how do we get around these obstacles?

`reactive` has additional parameters that are worth looking at. Of particular interest to us is the `env` parameter. It indicates the environment in which the expression passed as the first parameter should be evaluated. This is usually set as the environment calling the `reactive` function. So this is the reason why our original factory is not able to see the `input` object -- it is not in the environment calling `reactive`. So what happens if we replace this environment with the environment which calls our factory function?

```r
r_magic_func <- function(name_1, name_2, param) reactive({
  c(
    input[[name_1]] + input[[name_2]],
    input[[name_1]]^param * input[[name_2]],
    param^3 - (input[[name_2]] + input[[name_1]])
  )
}, env = rlang::caller_env())
```

![We got a different error! That's a progress!](/images/reactives-factory-error-2.png)

Why are we getting this error this time? Since we replaced the evaluation environment to the caller environment, it can see all objects available in the server environment, but now it cannot see the objects available inside the `r_magic_func`. Namely, name_1 (pun intended) and other parameters.

**Our favorite package comes to our rescue: rlang!** We can use similar idea with injection of values just as in the [previous tutorial](/2022/07/09/creating-observers-in-loop-shiny-reactivity-tricks-episode-one/).

```r
r_magic_func <- function(name_1, name_2, param) rlang::inject({
  reactive({
    c(
      input[[!!name_1]] + input[[!!name_2]],
      input[[!!name_1]]^(!!param) * input[[!!name_2]],
      (!!param)^3 - (input[[!!name_2]] + input[[!!name_1]])
    )
  }, env = rlang::caller_env())
})
```

And it fulfills all of our objectives! There is one more thing to do: if we really want to take care of the `r_magic_func`, we should ensure that this factory can also be called within other functions. So, instead of fixing the `env` parameter of `reactive` as the `rlang::caller_env()`, we should make it a default parameter of `r_magic_func`, similarly as `reactive` itself does it.

# Discussion & summary

My example will probably again seem too artificial and contrived to some of you, but I am not writing this for the sake of the brilliance of the example, but rather to teach the concept behind it. Probably many of you will find a suitable application for this method. Some may agitate that hiding the reactive behind a function is superfluous, but, in my opinion, it is just another step towards code readability. This kind of factory can be further generalized and improved, which I will talk about next time.

One more thing: modules. I still deliberately avoid using modules. What I am doing here could also be done using modules, although I think it is much less intuitive than in the previous part of the series. I will also write about modules another time (ah, too many of these topics!).

I have shown you how to use tools to change the evaluation environment to control code execution and, as a result, reduce unnecessary repetitions. This is only the second step on the long road to becoming a master at using the language to its full potential. If you have any questions or comments, contact us [on Twitter](https://twitter.com/Rturtletopia) or make an issue [on Github](https://github.com/turtletopia/turtletopia.github.io/issues).
