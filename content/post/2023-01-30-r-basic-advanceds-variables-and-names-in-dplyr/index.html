---
title: 'R Basic Advanceds: Variables and Names in dplyr'
author: Dominik Rafacz
date: '2023-01-30'
slug: r-basic-advanceds-variables-and-names-in-dplyr
categories: ['Tutorial']
tags: ['r', 'tutorial', 'dplyr', 'environments', 'rlang']
---



<div id="intro" class="section level1">
<h1>Intro</h1>
<p>Hello everyone! After an extended hiatus for various reasons (from graduating college to navigating job changes and legal challenges), we’re back and eager to breathe new life into this blog. Given my deep interest in the fundamentals of advanced methods, today we’re delving into an essential topic every dplyr user will eventually face.</p>
<p>dplyr is meticulously designed with the primary goal of making code workflows read as naturally and close to plain language as possible. This design philosophy manifests in two critical dimensions: <em>semantic</em> and <em>syntactic</em>.</p>
<p>Semantically, the emphasis is on <strong>employing words with intuitive and easily understood meanings</strong>. For instance, dplyr and its friends adhere to a robust naming convention where function names typically take on verb forms, elucidating the action they perform.</p>
<p>Syntactically, the <strong>arrangement and combination of these descriptive words is paramount</strong>. Arguably, this is even more critical to the user experience. One of the most evident manifestations of this syntactical approach is the tidyverse’s hallmark feature: <strong>the pipe operator</strong>. But we are not going to tackle this today. I will look into caveats of another essential and intuitive syntactic feature: the <strong>use of symbols instead of strings to refer to variables within datasets</strong>. This offers a more natural-feeling mode of interaction but, as I have found out over many years of using R, this feature can lead to some problems.</p>
</div>
<div id="problem-1-symbols-vs.-strings-with-names" class="section level1">
<h1>Problem 1: Symbols vs. strings with names</h1>
<p>Let’s compare how we select columns in a data frame using base R versus dplyr:</p>
<pre class="r"><code># base
iris[, c(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;)]

# dplyr
iris %&gt;%
  select(Sepal.Length, Sepal.Width)</code></pre>
<p>Notice the difference:</p>
<ul>
<li>In base R, we use <code>"Sepal.Length", "Sepal.Width"</code>, which are <strong>strings</strong> enclosed in quotes (single and double quotes are both valid).</li>
<li>With dplyr, we have <code>Sepal.Length, Sepal.Width</code>, unquoted <strong>symbols</strong>.</li>
</ul>
<p>In the second case <em>symbols</em> are used to access columns in a data frame, just like we use symbols to access any variable or function that we store in our top-level environments.
It is vital to grasp this distinction to sidestep potential pitfalls. which I will discuss in the rest of the post.</p>
<p>So, what symbols actually are? We use them as names of objects and this is the identity of their core. This is why it feels natural to use them to not only access top-level variables, but also variables in data. There is more to the nature of symbols, but we will come back to that later.</p>
<p>Notice that dplyr is smart enough to let you select variables by strings as well:</p>
<pre class="r"><code>iris %&gt;%
  select(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;)</code></pre>
<pre><code>##   Sepal.Length Sepal.Width
## 1          5.1         3.5
## 2          4.9         3.0
## 3          4.7         3.2
## 4          4.6         3.1
## 5          5.0         3.6</code></pre>
<p>This is, however, inadvisable, as this is exactly what tidyverse designers wanted to avoid.</p>
<p>Now, consider a scenario where we have an external variable storing column names:</p>
<pre class="r"><code>my_variables &lt;- c(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;)</code></pre>
<p>Although it might seem intuitive to directly supply it to select:</p>
<pre class="r"><code>iris %&gt;%
  select(my_variables)</code></pre>
<pre><code>## Warning: Using an external vector in selections was deprecated in tidyselect 1.1.0.
## ℹ Please use `all_of()` or `any_of()` instead.
##   # Was:
##   data %&gt;% select(my_variables)
## 
##   # Now:
##   data %&gt;% select(all_of(my_variables))
## 
## See &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;.
## This warning is displayed once every 8 hours.
## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was
## generated.</code></pre>
<pre><code>##   Sepal.Length Sepal.Width
## 1          5.1         3.5
## 2          4.9         3.0
## 3          4.7         3.2
## 4          4.6         3.1
## 5          5.0         3.6</code></pre>
<p>This generates a warning. Given the tidyverse’s informative error messages, it’s wise to pay heed. Directly supplying can be ambiguous —- imagine having a column named “my_variables”. Which should be selected if we have both the column and the external variable?</p>
<p><img src="/images/selection-ambiguity.png" alt="Diagram showing the dillema that dplyr is faced with when we torment it with ambiguous selections." />
To ensure clarity, dplyr authors suggest using dplyr::all_of(), which explicitly converts a name vector into symbols, resolving any ambiguities.</p>
<pre class="r"><code>iris %&gt;%
  select(all_of(my_variables))</code></pre>
<pre><code>##   Sepal.Length Sepal.Width
## 1          5.1         3.5
## 2          4.9         3.0
## 3          4.7         3.2
## 4          4.6         3.1
## 5          5.0         3.6</code></pre>
<div id="problem-2-passing-column-names-as-arguments-to-custom-functions" class="section level2">
<h2>Problem 2: Passing column names as arguments to custom functions</h2>
<p>Differentiating between passing a variable name or a symbol becomes trickier when constructing functions that internally use dplyr verbs. Consider:</p>
<pre class="r"><code>my_subset &lt;- function(data, my_var) {
  data %&gt;%
    select(my_var)
}</code></pre>
<p>This might cause a lot of issues. Should we provide a string as a name (<code>my_subset(iris, "Sepal.Length")</code>) or a symbol (<code>my_subset(iris, Sepal.Length)</code>)? To answer this question, <strong>we should first be clear about our intent</strong> (it would be nice to write a few words of documentation – for other users or for ourselves in the future). <strong>Both approaches are possible and valid</strong>. It is important to <strong>choose one and remain consistent</strong> across all functions that we write.</p>
<p>For instances where column names are passed as strings (common in Shiny apps when columns are selected by some input), one could utilize the previously discussed <code>dplyr::all_of()</code>:</p>
<pre class="r"><code>my_subset_with_strings &lt;- function(data, my_var_as_string) {
  data %&gt;%
    select(all_of(my_var_as_string))
}

my_subset_with_strings(iris, c(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;))</code></pre>
<p>If we want to use symbols, just like directly in dplyr functions (mostly when those columns to use are predefined, in our internal functions or analyses), we have to <em>embrace</em> the variable:</p>
<pre class="r"><code>my_subset_with_symbols &lt;- function(data, my_var_as_symbol) {
  data %&gt;%
    select({{ my_var_as_symbol }})
}

my_subset_with_symbols(iris, Petal.Length)

my_subset_with_symbols(iris, Petal.Length, Sepal.Width)</code></pre>
<p>In this way we let dplyr know that <code>my_var_as_symbol</code> has to be passed directly as user provided it. We can think of embracing as of cut-paste operation. We tell dplyr: “Take what user provided in place of <code>my_var_as_symbol</code> in function call and plug it directly into <code>select</code>, without creating any intermediate variables.”. Call to <code>my_subset_with_symbols()</code> is basically replaced with what lies inside of it.</p>
</div>
</div>
<div id="problem-3-dynamic-columns-in-purrr-formulas-in-across" class="section level1">
<h1>Problem 3: dynamic columns in purrr formulas in <code>across</code></h1>
<p>While the above solutions work seamlessly with functions like <code>dplyr::select()</code>, challenges arise when operations grow complex. Suppose we wish to craft a function, <code>do_magic</code>, that takes data, a special <code>column</code>, and several <code>others</code> columns. This function should add the special column to all others.</p>
<p>Leveraging <code>dplyr::mutate(dplyr::across())</code> can achieve this. Its syntax is:</p>
<pre class="r"><code>mutate(across(columns_to_mutate, function_to_apply))</code></pre>
<p>For custom, unnamed functions, the <em>purrr formula syntax</em> (<code>~ expression</code> with <code>.x</code>) is beneficial. In our case (without enclosing it in a function yet) could look like:</p>
<pre class="r"><code>iris %&gt;%
  mutate(across(all_of(c(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;)), ~ .x - Petal.Length))</code></pre>
<p>However, contrary to most languages, in R <strong>symbols can be treated as objects themselves</strong>. This allows dplyr to even perform such simplifications. The details are irrelevant now</p>
</div>
