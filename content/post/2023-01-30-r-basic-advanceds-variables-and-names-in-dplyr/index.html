---
title: 'R Basic Advanceds: Variables and Names in dplyr'
author: Dominik Rafacz
date: '2023-01-30'
slug: r-basic-advanceds-variables-and-names-in-dplyr
categories: ['Tutorial']
tags: ['r', 'tutorial', 'dplyr', 'environments', 'rlang']
---



<div id="intro" class="section level1">
<h1>Intro</h1>
<p>Hello everyone! After an extended hiatus for various reasons (from graduating college to navigating job changes and legal challenges), we’re back and eager to breathe new life into this blog. Given my deep interest in the fundamentals of advanced methods, today we’re delving into an essential topic every dplyr user will eventually face.</p>
<p>dplyr is meticulously designed with the primary goal of making code workflows read as naturally and close to plain language as possible. This design philosophy manifests in two critical dimensions: <em>semantic</em> and <em>syntactic</em>.</p>
<p>Semantically, the emphasis is on <strong>employing words with intuitive and easily understood meanings</strong>. For instance, dplyr and its friends adhere to a robust naming convention where function names typically take on verb forms, elucidating the action they perform.</p>
<p>Syntactically, the <strong>arrangement and combination of these descriptive words is paramount</strong>. Arguably, this is even more critical to the user experience. One of the most evident manifestations of this syntactical approach is the tidyverse’s hallmark feature: <strong>the pipe operator</strong>. But we are not going to tackle this today. I will look into caveats of another essential and intuitive syntactic feature: the <strong>use of symbols instead of strings to refer to variables within datasets</strong>. This offers a more natural-feeling mode of interaction but, as I have found out over many years of using R, this feature can lead to some problems.</p>
</div>
<div id="problem-1-symbols-vs.-strings-with-names" class="section level1">
<h1>Problem 1: Symbols vs. strings with names</h1>
<p>Let’s compare how we select columns in a data frame using base R versus dplyr:</p>
<pre class="r"><code># base
iris[, c(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;)]

# dplyr
iris %&gt;%
  select(Sepal.Length, Sepal.Width)</code></pre>
<p>Notice the difference:</p>
<ul>
<li>In base R, we use <code>"Sepal.Length", "Sepal.Width"</code>, which are <strong>strings</strong> enclosed in quotes (single and double quotes are both valid).</li>
<li>With dplyr, we have <code>Sepal.Length, Sepal.Width</code>, unquoted <strong>symbols</strong>.</li>
</ul>
<p>In the second case <em>symbols</em> are used to access columns in a data frame, just like we use symbols to access any variable or function that we store in our top-level environments.
It is vital to grasp this distinction to sidestep potential pitfalls. which I will discuss in the rest of the post.</p>
<p>So, what symbols actually are? We use them as names of objects and this is the identity of their core. This is why it feels natural to use them to not only access top-level variables, but also variables in data. There is more to the nature of symbols, but we will come back to that later.</p>
<p>Notice that dplyr is smart enough to let you select variables by strings as well:</p>
<pre class="r"><code>iris %&gt;%
  select(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;)</code></pre>
<pre><code>##   Sepal.Length Sepal.Width
## 1          5.1         3.5
## 2          4.9         3.0
## 3          4.7         3.2
## 4          4.6         3.1
## 5          5.0         3.6</code></pre>
<p>This is, however, inadvisable, as this is exactly what tidyverse designers wanted to avoid.</p>
<p>Now, consider a scenario where we have an external variable storing column names:</p>
<pre class="r"><code>my_variables &lt;- c(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;)</code></pre>
<p>Although it might seem intuitive to directly supply it to select:</p>
<pre class="r"><code>iris %&gt;%
  select(my_variables)</code></pre>
<pre><code>## Warning: Using an external vector in selections was deprecated in tidyselect 1.1.0.
## ℹ Please use `all_of()` or `any_of()` instead.
##   # Was:
##   data %&gt;% select(my_variables)
## 
##   # Now:
##   data %&gt;% select(all_of(my_variables))
## 
## See &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;.</code></pre>
<pre><code>##   Sepal.Length Sepal.Width
## 1          5.1         3.5
## 2          4.9         3.0
## 3          4.7         3.2
## 4          4.6         3.1
## 5          5.0         3.6</code></pre>
<p>This generates a warning. Given the tidyverse’s informative error messages, it’s wise to pay heed. Directly supplying can be ambiguous —- imagine having a column named “my_variables”. Which should be selected if we have both the column and the external variable?</p>
<p><img src="images/selection-ambiguity.png" alt="Diagram showing the dillema that dplyr is faced with when we torment it with ambiguous selections." />
To ensure clarity, dplyr authors suggest using dplyr::all_of(), which explicitly converts a name vector into symbols, resolving any ambiguities.</p>
<pre class="r"><code>iris %&gt;%
  select(all_of(my_variables))</code></pre>
<pre><code>##   Sepal.Length Sepal.Width
## 1          5.1         3.5
## 2          4.9         3.0
## 3          4.7         3.2
## 4          4.6         3.1
## 5          5.0         3.6</code></pre>
<div id="problem-2-passing-column-names-as-arguments-to-custom-functions" class="section level2">
<h2>Problem 2: Passing column names as arguments to custom functions</h2>
<p>Differentiating between passing a variable name or a symbol becomes trickier when constructing functions that internally use dplyr verbs. Consider:</p>
<pre class="r"><code>my_subset &lt;- function(data, my_var) {
  data %&gt;%
    select(my_var)
}</code></pre>
<p>This might cause a lot of issues. Should we provide a string as a name (<code>my_subset(iris, "Sepal.Length")</code>) or a symbol (<code>my_subset(iris, Sepal.Length)</code>)? To answer this question, <strong>we should first be clear about our intent</strong> (it would be nice to write a few words of documentation – for other users or for ourselves in the future). <strong>Both approaches are possible and valid</strong>. It is important to <strong>choose one and remain consistent</strong> across all functions that we write.</p>
<p>For instances where column names are passed as strings (common in Shiny apps when columns are selected by some input), one could utilize the previously discussed <code>dplyr::all_of()</code>:</p>
<pre class="r"><code>my_subset_with_strings &lt;- function(data, my_var_as_string) {
  data %&gt;%
    select(all_of(my_var_as_string))
}

my_subset_with_strings(iris, c(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;))</code></pre>
<p>If we want to use symbols, just like directly in dplyr functions (mostly when those columns to use are predefined, in our internal functions or analyses), we have to <em>embrace</em> the variable:</p>
<pre class="r"><code>my_subset_with_symbols &lt;- function(data, my_var_as_symbol) {
  data %&gt;%
    select({{ my_var_as_symbol }})
}

my_subset_with_symbols(iris, Petal.Length)

my_subset_with_symbols(iris, Petal.Length, Sepal.Width)</code></pre>
<p>In this way we let dplyr know that <code>my_var_as_symbol</code> has to be passed directly as user provided it. We can think of embracing as of cut-paste operation. We tell dplyr: “Take what user provided in place of <code>my_var_as_symbol</code> in function call and plug it directly into <code>select</code>, without creating any intermediate variables.”. Call to <code>my_subset_with_symbols()</code> is basically replaced with what lies inside of it.</p>
</div>
</div>
<div id="problem-3-dynamic-columns-in-purrr-formulas-in-across" class="section level1">
<h1>Problem 3: dynamic columns in purrr formulas in <code>across</code></h1>
<p>While the above solutions work seamlessly with functions like <code>dplyr::select()</code>, challenges arise when operations grow complex. Suppose we wish to craft a function, <code>do_magic</code>, that takes data, a special <code>column</code>, and several <code>others</code> columns. This function should add the special column to all others.</p>
<p>Leveraging <code>dplyr::mutate(dplyr::across())</code> can achieve this. Its syntax is:</p>
<pre class="r"><code>mutate(across(columns_to_mutate, function_to_apply))</code></pre>
<p>For custom, unnamed functions, the <em>purrr formula syntax</em> (<code>~ expression</code> with <code>.x</code>) is beneficial. In our case (without enclosing it in a function yet) could look like:</p>
<pre class="r"><code>iris %&gt;%
  mutate(across(all_of(c(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;)), ~ .x - Petal.Length))</code></pre>
<p>Elegant, isn’t it? Now, let’s proceed by encapsulating this logic within a function where column names are passed as strings:</p>
<pre class="r"><code>do_magic &lt;- function(data, special, others) {
  data %&gt;%
    mutate(across(all_of(others), ~ .x - all_of(special)))
}

# won&#39;t work:
# do_magic(iris, special = &quot;Petal.Length&quot;, others = c(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;))</code></pre>
<p>Surprisingly, it fails! When used within the context of <code>across</code>, dplyr seems unable to utilize the tidyselect rules (the ones that make <code>all_of()</code> possible). But we’re not defeated; let’s try embracing:</p>
<pre class="r"><code>do_magic_but_better &lt;- function(data, special, others) {
  data %&gt;%
    mutate(across(all_of(others), ~ .x - {{special}}))
}

do_magic_but_better(iris, special = Petal.Length, others = c(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;))</code></pre>
<pre><code>##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1          3.7         2.1          1.4         0.2  setosa
## 2          3.5         1.6          1.4         0.2  setosa
## 3          3.4         1.9          1.3         0.2  setosa
## 4          3.1         1.6          1.5         0.2  setosa
## 5          3.6         2.2          1.4         0.2  setosa</code></pre>
<p>By adopting this approach, it’s imperative to provide special as a symbol. Also, this does not look fine: one parameter is provided as symbol, another one is as character vector… <strong>We should always aim at being consistent</strong>. Either all column-like parameters should be symbols or all should be character strings. There are pros and cons to both ways. Let’s say that we want to stick to strings only. How can we do it?</p>
<div id="tip-when-all_of-does-not-work-use-.data" class="section level4">
<h4>Tip: when <code>all_of()</code> does not work, use <code>.data</code></h4>
<p>There’s a workaround for this conundrum:</p>
<pre class="r"><code>do_magic_but_in_other_way &lt;- function(data, special, others) {
  data %&gt;%
    mutate(across(all_of(others), ~ .x - .data[[special]]))
}

do_magic_but_in_other_way(iris, special = &quot;Petal.Length&quot;, others = c(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;))</code></pre>
<pre><code>##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1          3.7         2.1          1.4         0.2  setosa
## 2          3.5         1.6          1.4         0.2  setosa
## 3          3.4         1.9          1.3         0.2  setosa
## 4          3.1         1.6          1.5         0.2  setosa
## 5          3.6         2.2          1.4         0.2  setosa</code></pre>
<p>When you need to reference the underlying data within the context of functions, the <code>.data</code> pronoun comes to the rescue. As demonstrated, it operates similarly to directly accessing the data.</p>
</div>
<div id="summary-next-steps" class="section level2">
<h2>Summary &amp; Next Steps</h2>
<p>Throughout this post, we ventured deep into some of the intricacies of dplyr. We’ve unraveled how the package strives to make our code both semantic and syntactic, all while simplifying complex operations. The power of symbols and the utility of functions like <code>all_of()</code> and <code>.data</code> demonstrate just how dynamic and adaptable dplyr can be, especially when working with variable column names. While we’ve covered much ground, the world of dplyr is vast and constantly evolving. We are aware that all this <em>embracing</em> and <em>tidyselect</em> rules might be intimidating, but we will be continue to explore more facets of the tidyverse in future posts of “basic advanceds”, aiming to empower you with advanced techniques that enhance your data analysis journey.</p>
<p>If you’ve found this post enlightening and wish to delve deeper, or if you have any questions or insights, we’d love to hear from you! You can contact us directly via <a href="https://twitter.com/Rturtletopia">X</a>. Alternatively, for those who prefer a more open-source avenue, feel free to open an issue on our <a href="https://github.com/turtletopia/turtletopia.github.io/issues">GitHub</a> repository. Your feedback and insights not only help us improve, but they also contribute to the broader data science community.</p>
<p>Until next time, keep exploring, learning, and sharing!</p>
</div>
<div id="dive-deeper-resources-for-the-curious-minds" class="section level2">
<h2>Dive Deeper: Resources for the Curious Minds:</h2>
<p>For those wishing to delve further or who may have lingering questions: <a href="https://dplyr.tidyverse.org/articles/programming.html">Dplyr official programming guide</a></p>
</div>
</div>
